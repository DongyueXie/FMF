---
title: "Smoothed Matrix Factorization for Poisson data"
author: "Dongyue Xie"
date: "2019-07-30"
output: workflowr::wflow_html
editor_options:
  chunk_output_type: console
---

```{r global_options, include=FALSE}
knitr::opts_chunk$set(warning=FALSE, message=FALSE)
```

## Introduction

Consider a count matrix $Y\in$$R^{N\times p}$ whose underlying rows are smooth.  Each entry of the count matrix is assumed Poission distribution, $Y_{ij}\sim Pois(\lambda_{ij})$. Denote $\Lambda = \{\lambda_{ij}\}$ and assume $\Lambda = LF$, where $L$ is a $N\times K$ matrix and $F$ is a $K\times p$ matrix.

Algorithm

1. Initialize $\m_i=E(Y_{i\cdot})$.
2. Apply WaveEBMF to $Z$.


### Example

Simulate $N=200$ and $p=256$ under the factor model 
\[l_i\sim \pi_0\delta_0+(1-\pi_0)\sum_{m=1}^5\frac{1}{5}N(0,\sigma^2_m)\]

We set $K=3$ and three factors are step function, Heavysine and spike functions.


```{r}

library(wavethresh)
library(flashr)
library(ashr)

WaveEBMF = function(y,k,filter.number = 1,family = 'DaubExPhase'){
  N=nrow(y)
  p=ncol(y)
  W = GenW(n=p,filter.number = filter.number,family = family)
  y_tilde = y%*%W
  f2 = flash(y_tilde,Kmax=k,var_type = 'constant',backfit = T,verbose=F)
  f2_fitted = flash_get_ldf(f2)
  f_hat = (W%*%f2_fitted$f)
  return(list(f=f_hat,l=f2_fitted$l))
}

spike.f = function(x) (0.75 * exp(-500 * (x - 0.23)^2) + 1.5 * exp(-2000 * (x - 0.33)^2) + 3 * exp(-8000 * (x - 0.47)^2) + 2.25 * exp(-16000 * 
    (x - 0.69)^2) + 0.5 * exp(-32000 * (x - 0.83)^2))

set.seed(12345)
N = 200
p = 256
pi0 = 0.2
K=3
L = matrix(nrow=N,ncol=K)
for (i in 1:N) {
  for(j in 1:K){
    
    r = rbinom(1,1,pi0)
    if(r==1){
       L[i,j]=0
    }else{
      L[i,j] = mean(c(rnorm(1,0,sqrt(0.25)),rnorm(1,0,sqrt(0.5)),rnorm(1,0,sqrt(1)),
                    rnorm(1,0,sqrt(2)),rnorm(1,0,sqrt(4))))
    }
  }
}

f_1 = c(rep(2,p/4), rep(5, p/4), rep(6, p/4), rep(2, p/4))
f_2 = DJ.EX(p,signal = 2)$heavi
f_2 = f_2-min(f_2)+1
t = 1:p/p
f_3 = 2*spike.f(t)+1
FF = rbind(f_1,f_2,f_3)

L = abs(L)

Lambda = L%*%FF

Y = matrix(nrow=N,ncol=p)

for(i in 1:N){
  Y[i,] = rpois(p,Lambda[i,])
}

S = matrix(nrow=N,ncol = p)
Y_tilde = matrix(nrow = N,ncol = p)

for(i in 1:N){
  x.ash=ash(rep(0,p),1,lik=lik_pois(Y[i,]))$result$PosteriorMean
  m.hat=x.ash
  m.hat[which(Y[i,]!=0)]=(Y[i,][which(Y[i,]!=0)])
  Y_tilde[i,] = log(m.hat)+(Y[i,]-m.hat)/m.hat
  S[i,] = 1/m.hat
}


W = GenW(n=p,filter.number = 8,family = 'DaubLeAsymm')
y_star = Y_tilde%*%W
datax = flash_set_data(y_star,S=sqrt(S))
f2 = flash(datax,Kmax=3,var_type = 'zero',backfit = F,verbose=F)
f2_fitted = flash_get_ldf(f2)
f_hat = (W%*%f2_fitted$f)

plot(f_hat[,1],type='l')
plot(f_hat[,2],type='l')
plot(f_hat[,3],type='l')
```

## Summary

Possible reasons could be : ture $l$ is non-negative but we do not have the constraint for now. Try flashier

```{r}
library(flashier)
f3 = flashier(y_star,S,prior.family = list(prior.nonnegative()),greedy.Kmax = 3,var.type = 0,verbose.lvl = 0)


plot(f3$loadings.pm[[2]][,1],type='l')
plot(f3$loadings.pm[[2]][,2],type='l')
plot(f3$loadings.pm[[2]][,3],type='l')

```


Try NMF

```{r}
library(NMF)

```
